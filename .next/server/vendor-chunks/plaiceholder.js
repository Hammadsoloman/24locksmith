"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/plaiceholder";
exports.ids = ["vendor-chunks/plaiceholder"];
exports.modules = {

/***/ "(rsc)/./node_modules/plaiceholder/dist/plaiceholder.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/plaiceholder/dist/plaiceholder.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPlaiceholder: () => (/* binding */ getPlaiceholder)\n/* harmony export */ });\n/* harmony import */ var sharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sharp */ \"sharp\");\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _excluded = [\"a\"],\n    _excluded2 = [\"autoOrient\", \"size\", \"format\", \"brightness\", \"saturation\", \"removeAlpha\"],\n    _excluded3 = [\"width\", \"height\"];\n/* Utils\n   =========================================== */\n\nvar arrayChunk = function arrayChunk(arr, size) {\n  return arr.length > size ? [arr.slice(0, size)].concat(arrayChunk(arr.slice(size), size)) : [arr];\n};\n\nvar toRGBAString = function toRGBAString(_ref) {\n  var r = _ref.r,\n      g = _ref.g,\n      b = _ref.b,\n      a = _ref.a;\n  if (typeof a === \"undefined\") return \"rgb(\" + [r, g, b].join(\",\") + \")\";\n  return \"rgba(\" + [r, g, b, a].join(\",\") + \")\";\n};\n\nvar getPixels = function getPixels(_ref2) {\n  var _ref3;\n\n  var data = _ref2.data,\n      info = _ref2.info;\n  var channels = info.channels,\n      width = info.width;\n\n  var rawBuffer = (_ref3 = []).concat.apply(_ref3, data);\n\n  var allPixels = arrayChunk(rawBuffer, channels);\n  var rows = arrayChunk(allPixels, width);\n  var pixels = rows.map(function (row) {\n    return row.map(function (pixel) {\n      var r = pixel[0],\n          g = pixel[1],\n          b = pixel[2],\n          a = pixel[3];\n      return _extends({\n        r: r,\n        g: g,\n        b: b\n      }, typeof a === \"undefined\" ? {} : {\n        a: Math.round(a / 255 * 1000) / 1000\n      });\n    });\n  });\n  return pixels;\n};\n\nvar getCSS = function getCSS(_ref4) {\n  var pixels = _ref4.pixels,\n      info = _ref4.info;\n  var linearGradients = pixels.map(function (row) {\n    var rowPixels = row.map(function (pixel) {\n      return toRGBAString(pixel);\n    });\n    var gradient = rowPixels.map(function (pixel, i) {\n      var start = i === 0 ? \"\" : \" \" + i / rowPixels.length * 100 + \"%\";\n      var end = i === rowPixels.length ? \"\" : \" \" + (i + 1) / rowPixels.length * 100 + \"%\";\n      return \"\" + pixel + start + end;\n    }).join(\",\");\n    return \"linear-gradient(90deg, \" + gradient + \")\";\n  });\n\n  if (linearGradients.length !== info.height) {\n    console.error(\"Woops! Something went wrong here and caused the color height to differ from the source height.\");\n  }\n\n  var backgroundPosition = linearGradients.map(function (_, i) {\n    return i === 0 ? \"0 0 \" : \"0 \" + i / (linearGradients.length - 1) * 100 + \"%\";\n  }).join(\",\");\n  var backgroundSize = \"100% \" + 100 / linearGradients.length + \"%\";\n  return {\n    backgroundImage: linearGradients.join(\",\"),\n    backgroundPosition: backgroundPosition,\n    backgroundSize: backgroundSize,\n    backgroundRepeat: \"no-repeat\"\n  };\n};\n\nvar getSVG = function getSVG(_ref5) {\n  var _ref7;\n\n  var pixels = _ref5.pixels,\n      info = _ref5.info;\n  var chunkRects = pixels.map(function (row, y) {\n    return row.map(function (_ref6, x) {\n      var a = _ref6.a,\n          rgb = _objectWithoutPropertiesLoose(_ref6, _excluded);\n\n      var colorProps = typeof a !== \"undefined\" ? {\n        fill: toRGBAString(rgb),\n        \"fill-opacity\": a\n      } : {\n        fill: toRGBAString(rgb),\n        \"fill-opacity\": 1\n      };\n      return [\"rect\", _extends({}, colorProps, {\n        width: 1,\n        height: 1,\n        x: x,\n        y: y\n      })];\n    });\n  });\n\n  if (chunkRects.length !== info.height) {\n    console.error(\"Woops! Something went wrong here and caused the color height to differ from the source height.\");\n  }\n\n  var rects = (_ref7 = []).concat.apply(_ref7, chunkRects);\n\n  return [\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"100%\",\n    height: \"100%\",\n    shapeRendering: \"crispEdges\",\n    preserveAspectRatio: \"none\",\n    viewBox: \"0 0 \" + info.width + \" \" + info.height,\n    style: {\n      position: \"absolute\",\n      top: \"50%\",\n      left: \"50%\",\n      transformOrigin: \"top left\",\n      transform: \"translate(-50%, -50%)\",\n      right: 0,\n      bottom: 0\n    }\n  }, rects];\n};\n\nvar getPlaiceholder = function getPlaiceholder(src, _temp) {\n  var _ref8 = _temp === void 0 ? {} : _temp,\n      _ref8$autoOrient = _ref8.autoOrient,\n      autoOrient = _ref8$autoOrient === void 0 ? false : _ref8$autoOrient,\n      _ref8$size = _ref8.size,\n      size = _ref8$size === void 0 ? 4 : _ref8$size,\n      _ref8$format = _ref8.format,\n      format = _ref8$format === void 0 ? [\"png\"] : _ref8$format,\n      _ref8$brightness = _ref8.brightness,\n      brightness = _ref8$brightness === void 0 ? 1 : _ref8$brightness,\n      _ref8$saturation = _ref8.saturation,\n      saturation = _ref8$saturation === void 0 ? 1.2 : _ref8$saturation,\n      _ref8$removeAlpha = _ref8.removeAlpha,\n      removeAlpha = _ref8$removeAlpha === void 0 ? false : _ref8$removeAlpha,\n      options = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n\n  try {\n    /* Optimize\n      ---------------------------------- */\n    return Promise.resolve(sharp__WEBPACK_IMPORTED_MODULE_0__(src).metadata().then(function (_ref9) {\n      var width = _ref9.width,\n          height = _ref9.height,\n          metadata = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n\n      if (!width || !height) {\n        throw Error(\"Could not get required image metadata\");\n      }\n\n      return _extends({\n        width: width,\n        height: height\n      }, metadata);\n    })).then(function (metadata) {\n      var _sharp$resize;\n\n      var sizeMin = 4;\n      var sizeMax = 64;\n      var isSizeValid = sizeMin <= size && size <= sizeMax;\n      !isSizeValid && console.error([\"Please enter a `size` value between\", sizeMin, \"and\", sizeMax].join(\" \")); // initial optimization\n\n      var pipelineStage1 = (_sharp$resize = sharp__WEBPACK_IMPORTED_MODULE_0__(src).resize(size, size, {\n        fit: \"inside\"\n      })).toFormat.apply(_sharp$resize, format).modulate(_extends({\n        brightness: brightness,\n        saturation: saturation\n      }, options != null && options.hue ? {\n        hue: options == null ? void 0 : options.hue\n      } : {}, options != null && options.lightness ? {\n        lightness: options == null ? void 0 : options.lightness\n      } : {})); // alpha\n\n\n      var pipelineStage2 = removeAlpha === false ? pipelineStage1 : pipelineStage1.removeAlpha(); // autoOrientation\n\n      var pipelineStage3 = autoOrient === false ? pipelineStage2 : pipelineStage2.rotate();\n      var pipeline = pipelineStage3;\n      /* Return\n        ---------------------------------- */\n\n      return Promise.resolve(pipeline.clone().stats().then(function (_ref10) {\n        var _ref10$dominant = _ref10.dominant,\n            r = _ref10$dominant.r,\n            g = _ref10$dominant.g,\n            b = _ref10$dominant.b;\n        return {\n          r: r,\n          g: g,\n          b: b,\n          hex: \"#\" + [r, g, b].map(function (x) {\n            return x.toString(16).padStart(2, \"0\");\n          }).join(\"\")\n        };\n      })).then(function (color) {\n        return Promise.resolve(pipeline.clone().normalise().toBuffer({\n          resolveWithObject: true\n        }).then(function (_ref11) {\n          var data = _ref11.data,\n              info = _ref11.info;\n          return \"data:image/\" + info.format + \";base64,\" + data.toString(\"base64\");\n        })[\"catch\"](function (err) {\n          console.error(\"base64 generation failed\", err);\n          throw err;\n        })).then(function (base64) {\n          return Promise.resolve(pipeline.clone().raw().toBuffer({\n            resolveWithObject: true\n          }).then(function (_ref12) {\n            var data = _ref12.data,\n                info = _ref12.info;\n            var pixels = getPixels({\n              data: data,\n              info: info\n            });\n            var css = getCSS({\n              pixels: pixels,\n              info: info\n            });\n            var svg = getSVG({\n              pixels: pixels,\n              info: info\n            });\n            return {\n              pixels: pixels,\n              css: css,\n              svg: svg\n            };\n          })[\"catch\"](function (err) {\n            console.error(\"pixel generation failed\", err);\n            throw err;\n          })).then(function (_ref13) {\n            var pixels = _ref13.pixels,\n                css = _ref13.css,\n                svg = _ref13.svg;\n            return {\n              color: color,\n              css: css,\n              base64: base64,\n              metadata: metadata,\n              pixels: pixels,\n              svg: svg\n            };\n          });\n        });\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\n\n//# sourceMappingURL=plaiceholder.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGxhaWNlaG9sZGVyL2Rpc3QvcGxhaWNlaG9sZGVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQjs7QUFFMUI7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnQ0FBZ0M7QUFDdkM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQUs7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSDs7QUFFakgsNENBQTRDLGtDQUFLO0FBQ2pEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBLFFBQVEsSUFBSSxJQUFJOzs7QUFHaEIsa0dBQWtHOztBQUVsRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUUyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1zdGFydGVyLXByaXNtaWMtbWluaW1hbC10cy8uL25vZGVfbW9kdWxlcy9wbGFpY2Vob2xkZXIvZGlzdC9wbGFpY2Vob2xkZXIuZXNtLmpzPzE4NTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImFcIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcImF1dG9PcmllbnRcIiwgXCJzaXplXCIsIFwiZm9ybWF0XCIsIFwiYnJpZ2h0bmVzc1wiLCBcInNhdHVyYXRpb25cIiwgXCJyZW1vdmVBbHBoYVwiXSxcbiAgICBfZXhjbHVkZWQzID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIl07XG4vKiBVdGlsc1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG52YXIgYXJyYXlDaHVuayA9IGZ1bmN0aW9uIGFycmF5Q2h1bmsoYXJyLCBzaXplKSB7XG4gIHJldHVybiBhcnIubGVuZ3RoID4gc2l6ZSA/IFthcnIuc2xpY2UoMCwgc2l6ZSldLmNvbmNhdChhcnJheUNodW5rKGFyci5zbGljZShzaXplKSwgc2l6ZSkpIDogW2Fycl07XG59O1xuXG52YXIgdG9SR0JBU3RyaW5nID0gZnVuY3Rpb24gdG9SR0JBU3RyaW5nKF9yZWYpIHtcbiAgdmFyIHIgPSBfcmVmLnIsXG4gICAgICBnID0gX3JlZi5nLFxuICAgICAgYiA9IF9yZWYuYixcbiAgICAgIGEgPSBfcmVmLmE7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIFwicmdiKFwiICsgW3IsIGcsIGJdLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gIHJldHVybiBcInJnYmEoXCIgKyBbciwgZywgYiwgYV0uam9pbihcIixcIikgKyBcIilcIjtcbn07XG5cbnZhciBnZXRQaXhlbHMgPSBmdW5jdGlvbiBnZXRQaXhlbHMoX3JlZjIpIHtcbiAgdmFyIF9yZWYzO1xuXG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIGluZm8gPSBfcmVmMi5pbmZvO1xuICB2YXIgY2hhbm5lbHMgPSBpbmZvLmNoYW5uZWxzLFxuICAgICAgd2lkdGggPSBpbmZvLndpZHRoO1xuXG4gIHZhciByYXdCdWZmZXIgPSAoX3JlZjMgPSBbXSkuY29uY2F0LmFwcGx5KF9yZWYzLCBkYXRhKTtcblxuICB2YXIgYWxsUGl4ZWxzID0gYXJyYXlDaHVuayhyYXdCdWZmZXIsIGNoYW5uZWxzKTtcbiAgdmFyIHJvd3MgPSBhcnJheUNodW5rKGFsbFBpeGVscywgd2lkdGgpO1xuICB2YXIgcGl4ZWxzID0gcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiByb3cubWFwKGZ1bmN0aW9uIChwaXhlbCkge1xuICAgICAgdmFyIHIgPSBwaXhlbFswXSxcbiAgICAgICAgICBnID0gcGl4ZWxbMV0sXG4gICAgICAgICAgYiA9IHBpeGVsWzJdLFxuICAgICAgICAgIGEgPSBwaXhlbFszXTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHI6IHIsXG4gICAgICAgIGc6IGcsXG4gICAgICAgIGI6IGJcbiAgICAgIH0sIHR5cGVvZiBhID09PSBcInVuZGVmaW5lZFwiID8ge30gOiB7XG4gICAgICAgIGE6IE1hdGgucm91bmQoYSAvIDI1NSAqIDEwMDApIC8gMTAwMFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcGl4ZWxzO1xufTtcblxudmFyIGdldENTUyA9IGZ1bmN0aW9uIGdldENTUyhfcmVmNCkge1xuICB2YXIgcGl4ZWxzID0gX3JlZjQucGl4ZWxzLFxuICAgICAgaW5mbyA9IF9yZWY0LmluZm87XG4gIHZhciBsaW5lYXJHcmFkaWVudHMgPSBwaXhlbHMubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICB2YXIgcm93UGl4ZWxzID0gcm93Lm1hcChmdW5jdGlvbiAocGl4ZWwpIHtcbiAgICAgIHJldHVybiB0b1JHQkFTdHJpbmcocGl4ZWwpO1xuICAgIH0pO1xuICAgIHZhciBncmFkaWVudCA9IHJvd1BpeGVscy5tYXAoZnVuY3Rpb24gKHBpeGVsLCBpKSB7XG4gICAgICB2YXIgc3RhcnQgPSBpID09PSAwID8gXCJcIiA6IFwiIFwiICsgaSAvIHJvd1BpeGVscy5sZW5ndGggKiAxMDAgKyBcIiVcIjtcbiAgICAgIHZhciBlbmQgPSBpID09PSByb3dQaXhlbHMubGVuZ3RoID8gXCJcIiA6IFwiIFwiICsgKGkgKyAxKSAvIHJvd1BpeGVscy5sZW5ndGggKiAxMDAgKyBcIiVcIjtcbiAgICAgIHJldHVybiBcIlwiICsgcGl4ZWwgKyBzdGFydCArIGVuZDtcbiAgICB9KS5qb2luKFwiLFwiKTtcbiAgICByZXR1cm4gXCJsaW5lYXItZ3JhZGllbnQoOTBkZWcsIFwiICsgZ3JhZGllbnQgKyBcIilcIjtcbiAgfSk7XG5cbiAgaWYgKGxpbmVhckdyYWRpZW50cy5sZW5ndGggIT09IGluZm8uaGVpZ2h0KSB7XG4gICAgY29uc29sZS5lcnJvcihcIldvb3BzISBTb21ldGhpbmcgd2VudCB3cm9uZyBoZXJlIGFuZCBjYXVzZWQgdGhlIGNvbG9yIGhlaWdodCB0byBkaWZmZXIgZnJvbSB0aGUgc291cmNlIGhlaWdodC5cIik7XG4gIH1cblxuICB2YXIgYmFja2dyb3VuZFBvc2l0aW9uID0gbGluZWFyR3JhZGllbnRzLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgIHJldHVybiBpID09PSAwID8gXCIwIDAgXCIgOiBcIjAgXCIgKyBpIC8gKGxpbmVhckdyYWRpZW50cy5sZW5ndGggLSAxKSAqIDEwMCArIFwiJVwiO1xuICB9KS5qb2luKFwiLFwiKTtcbiAgdmFyIGJhY2tncm91bmRTaXplID0gXCIxMDAlIFwiICsgMTAwIC8gbGluZWFyR3JhZGllbnRzLmxlbmd0aCArIFwiJVwiO1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRJbWFnZTogbGluZWFyR3JhZGllbnRzLmpvaW4oXCIsXCIpLFxuICAgIGJhY2tncm91bmRQb3NpdGlvbjogYmFja2dyb3VuZFBvc2l0aW9uLFxuICAgIGJhY2tncm91bmRTaXplOiBiYWNrZ3JvdW5kU2l6ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiXG4gIH07XG59O1xuXG52YXIgZ2V0U1ZHID0gZnVuY3Rpb24gZ2V0U1ZHKF9yZWY1KSB7XG4gIHZhciBfcmVmNztcblxuICB2YXIgcGl4ZWxzID0gX3JlZjUucGl4ZWxzLFxuICAgICAgaW5mbyA9IF9yZWY1LmluZm87XG4gIHZhciBjaHVua1JlY3RzID0gcGl4ZWxzLm1hcChmdW5jdGlvbiAocm93LCB5KSB7XG4gICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKF9yZWY2LCB4KSB7XG4gICAgICB2YXIgYSA9IF9yZWY2LmEsXG4gICAgICAgICAgcmdiID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjYsIF9leGNsdWRlZCk7XG5cbiAgICAgIHZhciBjb2xvclByb3BzID0gdHlwZW9mIGEgIT09IFwidW5kZWZpbmVkXCIgPyB7XG4gICAgICAgIGZpbGw6IHRvUkdCQVN0cmluZyhyZ2IpLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBhXG4gICAgICB9IDoge1xuICAgICAgICBmaWxsOiB0b1JHQkFTdHJpbmcocmdiKSxcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogMVxuICAgICAgfTtcbiAgICAgIHJldHVybiBbXCJyZWN0XCIsIF9leHRlbmRzKHt9LCBjb2xvclByb3BzLCB7XG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH0pXTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKGNodW5rUmVjdHMubGVuZ3RoICE9PSBpbmZvLmhlaWdodCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJXb29wcyEgU29tZXRoaW5nIHdlbnQgd3JvbmcgaGVyZSBhbmQgY2F1c2VkIHRoZSBjb2xvciBoZWlnaHQgdG8gZGlmZmVyIGZyb20gdGhlIHNvdXJjZSBoZWlnaHQuXCIpO1xuICB9XG5cbiAgdmFyIHJlY3RzID0gKF9yZWY3ID0gW10pLmNvbmNhdC5hcHBseShfcmVmNywgY2h1bmtSZWN0cyk7XG5cbiAgcmV0dXJuIFtcInN2Z1wiLCB7XG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBzaGFwZVJlbmRlcmluZzogXCJjcmlzcEVkZ2VzXCIsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsXG4gICAgdmlld0JveDogXCIwIDAgXCIgKyBpbmZvLndpZHRoICsgXCIgXCIgKyBpbmZvLmhlaWdodCxcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIHRvcDogXCI1MCVcIixcbiAgICAgIGxlZnQ6IFwiNTAlXCIsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IFwidG9wIGxlZnRcIixcbiAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgLTUwJSlcIixcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfVxuICB9LCByZWN0c107XG59O1xuXG52YXIgZ2V0UGxhaWNlaG9sZGVyID0gZnVuY3Rpb24gZ2V0UGxhaWNlaG9sZGVyKHNyYywgX3RlbXApIHtcbiAgdmFyIF9yZWY4ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBfcmVmOCRhdXRvT3JpZW50ID0gX3JlZjguYXV0b09yaWVudCxcbiAgICAgIGF1dG9PcmllbnQgPSBfcmVmOCRhdXRvT3JpZW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY4JGF1dG9PcmllbnQsXG4gICAgICBfcmVmOCRzaXplID0gX3JlZjguc2l6ZSxcbiAgICAgIHNpemUgPSBfcmVmOCRzaXplID09PSB2b2lkIDAgPyA0IDogX3JlZjgkc2l6ZSxcbiAgICAgIF9yZWY4JGZvcm1hdCA9IF9yZWY4LmZvcm1hdCxcbiAgICAgIGZvcm1hdCA9IF9yZWY4JGZvcm1hdCA9PT0gdm9pZCAwID8gW1wicG5nXCJdIDogX3JlZjgkZm9ybWF0LFxuICAgICAgX3JlZjgkYnJpZ2h0bmVzcyA9IF9yZWY4LmJyaWdodG5lc3MsXG4gICAgICBicmlnaHRuZXNzID0gX3JlZjgkYnJpZ2h0bmVzcyA9PT0gdm9pZCAwID8gMSA6IF9yZWY4JGJyaWdodG5lc3MsXG4gICAgICBfcmVmOCRzYXR1cmF0aW9uID0gX3JlZjguc2F0dXJhdGlvbixcbiAgICAgIHNhdHVyYXRpb24gPSBfcmVmOCRzYXR1cmF0aW9uID09PSB2b2lkIDAgPyAxLjIgOiBfcmVmOCRzYXR1cmF0aW9uLFxuICAgICAgX3JlZjgkcmVtb3ZlQWxwaGEgPSBfcmVmOC5yZW1vdmVBbHBoYSxcbiAgICAgIHJlbW92ZUFscGhhID0gX3JlZjgkcmVtb3ZlQWxwaGEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjgkcmVtb3ZlQWxwaGEsXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjgsIF9leGNsdWRlZDIpO1xuXG4gIHRyeSB7XG4gICAgLyogT3B0aW1pemVcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNoYXJwKHNyYykubWV0YWRhdGEoKS50aGVuKGZ1bmN0aW9uIChfcmVmOSkge1xuICAgICAgdmFyIHdpZHRoID0gX3JlZjkud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZjkuaGVpZ2h0LFxuICAgICAgICAgIG1ldGFkYXRhID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjksIF9leGNsdWRlZDMpO1xuXG4gICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IHJlcXVpcmVkIGltYWdlIG1ldGFkYXRhXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9LCBtZXRhZGF0YSk7XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICB2YXIgX3NoYXJwJHJlc2l6ZTtcblxuICAgICAgdmFyIHNpemVNaW4gPSA0O1xuICAgICAgdmFyIHNpemVNYXggPSA2NDtcbiAgICAgIHZhciBpc1NpemVWYWxpZCA9IHNpemVNaW4gPD0gc2l6ZSAmJiBzaXplIDw9IHNpemVNYXg7XG4gICAgICAhaXNTaXplVmFsaWQgJiYgY29uc29sZS5lcnJvcihbXCJQbGVhc2UgZW50ZXIgYSBgc2l6ZWAgdmFsdWUgYmV0d2VlblwiLCBzaXplTWluLCBcImFuZFwiLCBzaXplTWF4XS5qb2luKFwiIFwiKSk7IC8vIGluaXRpYWwgb3B0aW1pemF0aW9uXG5cbiAgICAgIHZhciBwaXBlbGluZVN0YWdlMSA9IChfc2hhcnAkcmVzaXplID0gc2hhcnAoc3JjKS5yZXNpemUoc2l6ZSwgc2l6ZSwge1xuICAgICAgICBmaXQ6IFwiaW5zaWRlXCJcbiAgICAgIH0pKS50b0Zvcm1hdC5hcHBseShfc2hhcnAkcmVzaXplLCBmb3JtYXQpLm1vZHVsYXRlKF9leHRlbmRzKHtcbiAgICAgICAgYnJpZ2h0bmVzczogYnJpZ2h0bmVzcyxcbiAgICAgICAgc2F0dXJhdGlvbjogc2F0dXJhdGlvblxuICAgICAgfSwgb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHVlID8ge1xuICAgICAgICBodWU6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaHVlXG4gICAgICB9IDoge30sIG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmxpZ2h0bmVzcyA/IHtcbiAgICAgICAgbGlnaHRuZXNzOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmxpZ2h0bmVzc1xuICAgICAgfSA6IHt9KSk7IC8vIGFscGhhXG5cblxuICAgICAgdmFyIHBpcGVsaW5lU3RhZ2UyID0gcmVtb3ZlQWxwaGEgPT09IGZhbHNlID8gcGlwZWxpbmVTdGFnZTEgOiBwaXBlbGluZVN0YWdlMS5yZW1vdmVBbHBoYSgpOyAvLyBhdXRvT3JpZW50YXRpb25cblxuICAgICAgdmFyIHBpcGVsaW5lU3RhZ2UzID0gYXV0b09yaWVudCA9PT0gZmFsc2UgPyBwaXBlbGluZVN0YWdlMiA6IHBpcGVsaW5lU3RhZ2UyLnJvdGF0ZSgpO1xuICAgICAgdmFyIHBpcGVsaW5lID0gcGlwZWxpbmVTdGFnZTM7XG4gICAgICAvKiBSZXR1cm5cbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBpcGVsaW5lLmNsb25lKCkuc3RhdHMoKS50aGVuKGZ1bmN0aW9uIChfcmVmMTApIHtcbiAgICAgICAgdmFyIF9yZWYxMCRkb21pbmFudCA9IF9yZWYxMC5kb21pbmFudCxcbiAgICAgICAgICAgIHIgPSBfcmVmMTAkZG9taW5hbnQucixcbiAgICAgICAgICAgIGcgPSBfcmVmMTAkZG9taW5hbnQuZyxcbiAgICAgICAgICAgIGIgPSBfcmVmMTAkZG9taW5hbnQuYjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiByLFxuICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgYjogYixcbiAgICAgICAgICBoZXg6IFwiI1wiICsgW3IsIGcsIGJdLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICAgICAgICB9KS5qb2luKFwiXCIpXG4gICAgICAgIH07XG4gICAgICB9KSkudGhlbihmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwaXBlbGluZS5jbG9uZSgpLm5vcm1hbGlzZSgpLnRvQnVmZmVyKHtcbiAgICAgICAgICByZXNvbHZlV2l0aE9iamVjdDogdHJ1ZVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfcmVmMTEpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IF9yZWYxMS5kYXRhLFxuICAgICAgICAgICAgICBpbmZvID0gX3JlZjExLmluZm87XG4gICAgICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9cIiArIGluZm8uZm9ybWF0ICsgXCI7YmFzZTY0LFwiICsgZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImJhc2U2NCBnZW5lcmF0aW9uIGZhaWxlZFwiLCBlcnIpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKGJhc2U2NCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGlwZWxpbmUuY2xvbmUoKS5yYXcoKS50b0J1ZmZlcih7XG4gICAgICAgICAgICByZXNvbHZlV2l0aE9iamVjdDogdHJ1ZVxuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9yZWYxMikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBfcmVmMTIuZGF0YSxcbiAgICAgICAgICAgICAgICBpbmZvID0gX3JlZjEyLmluZm87XG4gICAgICAgICAgICB2YXIgcGl4ZWxzID0gZ2V0UGl4ZWxzKHtcbiAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgaW5mbzogaW5mb1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgY3NzID0gZ2V0Q1NTKHtcbiAgICAgICAgICAgICAgcGl4ZWxzOiBwaXhlbHMsXG4gICAgICAgICAgICAgIGluZm86IGluZm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHN2ZyA9IGdldFNWRyh7XG4gICAgICAgICAgICAgIHBpeGVsczogcGl4ZWxzLFxuICAgICAgICAgICAgICBpbmZvOiBpbmZvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBpeGVsczogcGl4ZWxzLFxuICAgICAgICAgICAgICBjc3M6IGNzcyxcbiAgICAgICAgICAgICAgc3ZnOiBzdmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwicGl4ZWwgZ2VuZXJhdGlvbiBmYWlsZWRcIiwgZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoX3JlZjEzKSB7XG4gICAgICAgICAgICB2YXIgcGl4ZWxzID0gX3JlZjEzLnBpeGVscyxcbiAgICAgICAgICAgICAgICBjc3MgPSBfcmVmMTMuY3NzLFxuICAgICAgICAgICAgICAgIHN2ZyA9IF9yZWYxMy5zdmc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgIGNzczogY3NzLFxuICAgICAgICAgICAgICBiYXNlNjQ6IGJhc2U2NCxcbiAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICBwaXhlbHM6IHBpeGVscyxcbiAgICAgICAgICAgICAgc3ZnOiBzdmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGdldFBsYWljZWhvbGRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhaWNlaG9sZGVyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/plaiceholder/dist/plaiceholder.esm.js\n");

/***/ })

};
;